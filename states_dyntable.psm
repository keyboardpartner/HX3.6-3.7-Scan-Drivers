                        ; ##############################################################################
                        ;
                        ;     #####  #######    #    ####### #######  #####
                        ;    #     #    #      # #      #    #       #     #
                        ;    #          #     #   #     #    #       #
                        ;     #####     #    #     #    #    #####    #####
                        ;          #    #    #######    #    #             #
                        ;    #     #    #    #     #    #    #       #     #
                        ;     #####     #    #     #    #    #######  #####
                        ;
                        ; ##############################################################################
                        ;
                        ;
                        ; -------------------------- Mealy-Zustandsautomat -----------------------------
                        ;
                        ; State in s2: c_state_idle, c_state_forward, c_state_stopped, c_state_reverse
                        ;
                        ; ------------------------------------------------------------------------------
                        ;
          local_states:
                        ; Zustand der State Machine holen, wg. Geschwindigheit hier separat
                        CALL local_rd_state_s2                ; Timer-State dieser Taste in s2
                        ; auf derzeitigen Zustand verteilen
                        COMPARE s2, c_state_idle
                        JUMP Z, local_idle
                        COMPARE s2, c_state_forward
                        JUMP Z, local_forward
                        COMPARE s2, c_state_reverse
                        JUMP Z, local_reverse
                        JUMP local_stopped                    ; s2 kann hier nur noch c_state_stopped sein
                        ;
                        ; ------------------------------- State "Idle" ---------------------------------
                        ;
        local_idle_off:
                        ; Erstmals Ruhestellung, Dyntimer löschen
                        LOAD s0, 00
                        CALL local_wr_dyntimer_s0
                        LOAD s2, c_state_idle                 ; nächster Timer-State: Idle, OFF gesendet
                        CALL local_wr_state_s2
                        JUMP local_wr_s3_keystat              ; aktuellen Zustand für Early Key in RAM speichern
                        ;
            local_idle:
                        COMPARE s3_keystatus, c_key_idle      ; Hat Taste mindestens ersten Kontakt erreicht?
                        RETURN Z                              ; nichts machen
                        ; JUMP local_forward                  ; wenn ja, in Counting-State gehen
                        ;
                        ; ------------------------------ State "Forward" --------------------------------
                        ;
         local_forward:
                        ;
                        ; Nur 1. Kontakt erreicht: Solange Taste in Bewegung ist, Timerwert verringern
                        CALL local_rd_dyntimer_s0             ; gelesener Dyntimer-Wert in s0, Startwert 0, zählt bis 1 herunter
                        COMPARE s0, 01
                        CALL NZ, local_sub_s0                 ; -1
                        STORE s0, s_last_keytime              ; neuer Raw-Wert Dynamik
                        CALL local_wr_dyntimer_s0             ; Timer mit s0 neu setzen
                        CALL local_wr_s3_keystat              ; aktuellen Zustand für Early Key in RAM speichern
                        ;
                        ; Falls gewünscht ist, dass die Taste auch bei erstem Kontakt irgendwann sendet
                        ; FETCH s0, s_last_keytime              ; letzte gemessene ZEIT
                        ; COMPARE s0, 01              
                        ; JUMP Z, local_stop_0                  ; nur gaaanz langsam erreicht
                        ;
                        COMPARE s3_keystatus, c_key_dirty     ; nur 2. Kontakt?
                        JUMP Z, local_stop_0                  ; 2. Kontakt erreicht, 1. evt. fehlerhaft
                        COMPARE s3_keystatus, c_key_on
                        JUMP Z, local_stop_0                  ; 1. und 2. Kontakt erreicht: neuer State, MIDI senden
                        COMPARE s3_keystatus, c_key_idle
                        JUMP Z, local_reverse_0               ; Taste hat alle Kontakte verlassen, wieder auf Rückweg
       local_forward_0:
                        COMPARE s2, c_state_forward
                        RETURN Z                              ; State nicht neu setzen, wenn bereits Counting
                        LOAD s2, c_state_forward              ; wenn noch nicht gestartet, neuer Timer-State
                        JUMP local_wr_state_s2                ; neuer Timer-State: c_state_forward
                        ;
          local_sub_s0:
                        SUB s0, 01
                        RETURN
                        ;
                        ; ------------------------------ State "Stopped" -------------------------------
                        ;
         local_stopped: ; 2. Kontakt erreicht
                        COMPARE s3_keystatus, c_key_idle
                        JUMP Z, local_reverse_0               ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                        COMPARE s3_keystatus, c_key_moving
                        JUMP Z, local_reverse_0               ; Taste hat zweiten Kontakt verlassen, bewegt sich zurück
          local_stop_0:
                        COMPARE s2, c_state_stopped           ; bereits gestoppt und gesendet?
                        RETURN Z                              ; nichts machen, wenn bereits gestoppt
                        LOAD s2, c_state_stopped
                        CALL local_wr_state_s2                ; neuer Timer-State: c_state_stopped
                        JUMP local_states_on                  ; Dynamik-Wert eintragen, MIDI ON senden und Ende
                        ;
                        ; ------------------------------ State "Reverse" -------------------------------
                        ;
         local_reverse:
                        COMPARE s3_keystatus, c_key_idle
                        JUMP Z, local_idle_off                ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                        COMPARE s3_keystatus, c_key_on
                        JUMP Z, local_retrig                  ; Taste hat Endkontakt nochmal erreicht
                        COMPARE s3_keystatus, c_key_dirty
                        JUMP Z, local_retrig                  ; Taste hat Endkontakt nochmal erreicht
       local_reverse_0: ; erstmals auf dem Rückweg
                        COMPARE s2, c_state_reverse           ; bereits c_state_reverse?
                        RETURN Z                              ; dann zurück
                        LOAD s2, c_state_reverse
                        CALL local_wr_state_s2                ; neuer Timer-State: c_state_reverse
                        JUMP local_states_off                 ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                        ;
          local_retrig: ; Retrigger mit etwas verringertem Dynamik-Wert wenn erneut ON
                        LOAD s2, c_state_stopped              ; nächster Timer-State: Stopped
                        CALL local_wr_state_s2
                        CALL local_rd_dyntimer_s0
                        LOAD s1, A0                           ; zweiter Anschlag etwas geringer
                        CALL mult_soft_s0_s1                  ; s0 x s1 => s8_msb, s7_lsb, s0 bleibt bestehen
                        ADD  s8_msb, 01                       ; Zeit nicht 0 werden lassen
                        STORE s8_msb, s_last_keytime          ; neuer Raw-Wert Dynamik
                        JUMP local_states_on                  ; Dynamik-Wert holen, MIDI ON senden und Ende
                        ;
                        ; ------------------------------------------------------------------------------
                        ; Lokale Dyntimer und States lesen/schreiben
                        ; ------------------------------------------------------------------------------
                        ;
  local_wr_dyntimer_s0: ;  Taste in RAM_ADDR, zu schreibende Daten in s0
                        LOAD s6_idx_ptr, c_page_dyntimer
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        OUTPUT s5_scan_key, RAM_ADDR          ; Tastennummer
                        OUTPUT s0, RAM_WRDATA                 ; zu schreibende Daten
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)               ; Upper, Lower oder Pedal Strobe
                        RETURN
                        ;
  local_rd_dyntimer_s0: ; Taste in s5_scan_key, gelesene Daten später in s0
                        LOAD s6_idx_ptr, c_page_dyntimer
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        OUTPUT s5_scan_key, RAM_ADDR          ; Tastennummer
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_read_mask
                        INPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Read
                        RETURN                                ; Zustand in s0
                        ;
     local_wr_state_s2: ; zu schreibende Daten in s2, Taste in RAM_ADDR
                        LOAD s6_idx_ptr, c_page_keystate
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        OUTPUT s5_scan_key, RAM_ADDR          ; Tastennummer
                        OUTPUT s2, RAM_WRDATA                 ; zu schreibende Daten
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s2, (s6_idx_ptr)               ; Upper, Lower oder Pedal Strobe
                        RETURN
                        ;
     local_rd_state_s2: ; Taste in s5_scan_key, gelesene Daten später in s2
                        LOAD s6_idx_ptr, c_page_keystate
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        OUTPUT s5_scan_key, RAM_ADDR          ; Tastennummer
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_read_mask
                        INPUT s2, (s6_idx_ptr)                ; Timer-State dieser Taste in s2
                        RETURN
                        ;
   local_wr_s3_keystat: ; s3_keystatus auf Adresse s_local_key speichern
                        LOAD s6_idx_ptr, c_page_earlystep
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        FETCH s0, s_local_key                 ; Taste
                        OUTPUT s0, RAM_ADDR                   ; Tastennummer
                        ; gleich hier in local_steps umrechnen
                        LOAD s1, s3_keystatus
                        COMPARE s1, 00
                        JUMP Z, local_wr_s3_keystat_0         ; wenn OFF, weiter mit 0
                        FETCH s0, s_last_keytime              ; letzte gemessene ZEIT
                        COMPARE s0, 00
                        CALL NZ, local_time2s0                ; in 2 Stufen umrechnen
                        LOAD s1, 03
 local_wr_s3_keystat_0:
                        OUTPUT s1, RAM_WRDATA                 ; zu schreibende Zustand in s1
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)               ; Upper, Lower oder Pedal Strobe
                        RETURN
                        ;
         local_time2s0:
                        COMPARE s0, c_time_threshold          ; Zeitschwelle, 255 = schnellste Taste, 1 = langsamste Taste
                        JUMP C, local_time2s0_0               ; JUMP wenn kleiner
                        LOAD&RETURN s0, 01                  
        local_time2s0_0:
                        LOAD&RETURN s0, 03                    ; ist schnell
                        ;
       local_wr_dynkey:
                        ; Scanned-RAM Dynamik
                        ; Taste in s5_scan_key, s_local_dyn und s9_manual_select
                        LOAD s6_idx_ptr, c_page_velocity
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        FETCH s0, s_local_key                 ; Taste
                        OUTPUT s0, RAM_ADDR                   ; Tastennummer
                        ; Dynamik schreiben
                        FETCH s0, s_local_dyn                 ; Dynamik dieser Taste
                        OUTPUT s0, RAM_WRDATA                 ; zu schreibende Dynamik in s0
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)               ; Upper, Lower oder Pedal Strobe
                        ; Umgerechnet in 2 Stufen für Event-Loop
                        LOAD s6_idx_ptr, c_page_latestep
                        OUTPUT s6_idx_ptr, RAM_PAGE           ; MPX-RAM Page
                        FETCH s0, s_local_dyn                 ; Dynamik dieser Taste
                        COMPARE s0, 00
                        CALL NZ, event_dyn2s0
                        OUTPUT s0, RAM_WRDATA                 ; zu schreibende Dynamik in s0
                        LOAD s6_idx_ptr, s9_manual_select     ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)               ; Upper, Lower oder Pedal Strobe
                        RETURN
                        ;
                        ; ------------------------------------------------------------------------------
                        ;
       local_states_on:
                        ; Dynamik-Kurvenwert aus Tabelle holen
                        FETCH s0, s_last_keytime              ; Raw-Dynamik holen, 0 = schnellste Taste, 1 = langsamste Taste
                        COMPARE s0, 00                        ; 0 = Schnellste Taste?
                        CALL Z, load_s0_with_FF               ; dann auf 255 = schnellste Taste setzen  
                        ADD s0, c_time_offset                 ; Offset von gemessener Zeit 
                        CALL C, load_s0_with_FF               ; wenn Zeit über Schwelle, auf 255 = schnellste Taste setzen
     local_states_on_0: ; Wert in s0 jetzt 1 bis 255, 1 = langsamste Taste, 255 = schnellste Taste
                        XOR s0, FF                            ; invertieren, 0 = schnellste Taste, 254 = langsamste Taste
                        OUTPUT s0, DYN_TABLE_ADDR             ; Adresse für Dyntable schreiben
                        LOAD s0, s0                           ; Delay für BRAM Zugriff
                        INPUT s0, DYN_TABLE                   ; Dyntable-Wert in s0, 127 = schnellste Taste, 10 = langsamste Taste
                        STORE s0, s_local_dyn
                        JUMP local_states_out
                        ;
                        ; ------------------------------------------------------------------------------
                        ;
      local_states_off:
                        LOAD s0, 00
                        STORE s0, s_local_dyn
                        ;
                        ; ------------------------------------------------------------------------------
                        ; MIDI SEND und Abschaltung über SPI $0E/2E (#14 in Firmware)
                        ; ------------------------------------------------------------------------------
                        ;
      local_states_out: ; s_local_key und s_local_dyn senden
                        ; Dynamik in s_local_dyn, Taste in s_local_key, für aktuelles Manual schreiben
                        CALL local_wr_dynkey
                        ; Parameter SPI #14 = LOCAL MIDI SEND auswerten, Bit 0 = Cancel MIDI Kanal UPPER, 1 = LOWER, 2 = PEDAL
                        INPUT s0, SPI_MIDISEND_DISABLES
                        TEST s0, 07                           ; alle Disable-Bits 0 bis 2
                        JUMP Z, local_states_send             ; gar kein Disable gesetzt wenn 0, also senden
                        ;
                        TEST s0, 01                           ; Bit 0 = UPPER
                        JUMP Z, local_states_out_1            ; kein Disable wenn 0
                        COMPARE s9_manual_select, 00
                        RETURN Z
    local_states_out_1:
                        TEST s0, 02                           ; Bit 1 = LOWER
                        JUMP Z, local_states_out_2            ; kein Disable wenn 0
                        COMPARE s9_manual_select, 01
                        RETURN Z
    local_states_out_2:
                        TEST s0, 04                           ; Bit 2 = PEDAL
                        JUMP Z, local_states_send             ; kein Disable wenn 0
                        COMPARE s9_manual_select, 02
                        RETURN Z
     local_states_send:
                        ; Manual in s9_manual_select, On/Off-Dynamik in s_local_dyn
                        ; immer auch an SAM5504 dh. MIDI_TX_SAM senden
                        FETCH s0, s_midich                    ; eingestellter Kanal
                        ADD s0, s9_manual_select              ; Manual-Nummer addieren
                        OR s0, 90
                        CALL midi_tx_s0
                        ;
                        FETCH s0, s_local_key
                        ADD s0, c_midi_offset                 ; transp. Key in s0
                        INPUT s1, SPI_KEYTRANSPOSE            ; MIDI-OUT-Transpose
                        ADD s0, s1
                        CALL midi_tx_s0
                        ;
                        FETCH s0, s_local_dyn                 ; gemessene Dynamik
                        JUMP midi_tx_s0                       ; 0 = OFF senden
                        ;
                        ; ------------------------------------------------------------------------------
                        ; Multiplier 8x8 unsigned, s0 x s1, Ergebnis in msb und lsb, s0 wird nicht verändert
                        ; ------------------------------------------------------------------------------
                        ;
        square_soft_s0: ; s0 squared => s8_msb, s7_lsb
                        LOAD s1, s0
       mult_soft_s0_s1: ; s0 x s1 => s8_msb, s7_lsb
                        LOAD s8_msb, 00
                        LOAD s6_idx_ptr, 08                   ; Schleifenzähler
             mult_loop:
                        SR0 s1
                        CALL C, mult_shift_add_s8
                        SRA s8_msb
                        SRA s7_lsb
                        SUB s6_idx_ptr, 01
                        JUMP NZ, mult_loop
                        RETURN
                        ;
     mult_shift_add_s8:
                        ADD s8_msb, s0
                        RETURN
                        ;
                        ; ------------------------------------------------------------------------------
                        ;
       load_s0_with_FF:
                        LOAD&RETURN s0, FF
                        ;
       load_s0_with_7F:
                        LOAD&RETURN s0, 7F
                        ;
       load_s0_with_01:
                        LOAD&RETURN s0, 01
                        ;
   load_s0_with_mindyn:
                        LOAD&RETURN s0, c_midi_mindyn
                        ;
       load_s8_with_01:
                        LOAD&RETURN s8_msb, 01                ; s8_msb = 1
                        ;
