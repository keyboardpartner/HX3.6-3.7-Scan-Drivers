                      ;
                      ; ##############################################################################
                      ;
                      ;    #     # ######   #####        # #     # ######  #######
                      ;     #   #  #     # #     #      #   #   #  #     # #
                      ;      # #   #     #       #     #     # #   #     # #
                      ;       #    ######   #####     #       #    ######  ######
                      ;      # #   #     # #         #       # #   #     #       #
                      ;     #   #  #     # #        #       #   #  #     # #     #
                      ;    #     # ######  ####### #       #     # ######   #####
                      ;
                      ; ##############################################################################
                      ;
                      ;
                      ; 26.02.2026 #52 für FPGA ab #23022024, mit ladbarer Dynamik-Tabelle, siehe "states_dyntable.psm"
                      ; 27.01.2026 #51 Neues universelles Framework, hier für Fatar 61-Tastatur mit 8x8 Matrix und FatarScan2-Board (alt)
                      ; 10.12.2025 #49 Support für neues FPGA mit separatem SAM5504-MIDI-FIFO, MIDI GETBYTE gestrafft
                      ; 11.07.2025 #47 Neue Organisation der Tastenabfrage mit vertauschter Spalte/Reihe (4017/4024-Zähler), deutlich schneller
                      ; 23.07.2024 #46 Bugfix: MIDI SEND ENABLES waren nicht implementiert, siehe "local_states_out"
                      ; 13.06.2024 #44 Differenzierter Key Click, etwas schwächer; #45 einstellbar on/off
                      ; 29.06.2022 #42 MIDI IN/GenTranspose jetzt für alle, KeyTranspose (Offset) nur MIDI OUT
                      ; 11.01.2022 #41 Extrem verbessertes Timing, 500µs Scan-Loop, einfacheres RAM-Handling
                      ; 31.12.2021 #40 Key Reverse State beim Verlassen der Endstellung, sendet früher, Noise etwas verringert
                      ; 18.10.2021 #39 Octave Shift für Upper und Lower in Manual Scan
                      ; 30.07.2021 #37 Sendet page_init bei Split-Änderungen, SplitMode 5 (AddPedalToLower)
                      ; 18.05.2021 #36 Andere Noise-Berechnung
                      ; 12.01.2021 #33 Bug in ResetDynTimers behoben
                      ; 12.01.2021 #31 Dynamik-Ermittlung über variables Timer-Dekrement (1/t)
                      ; 09.01.2021 #30 Scan-Dynamik jetzt per Statemachine
                      ; 03.09.2020 #28 Keine Übersetzung Sostenuto mehr
                      ; 22.02.2020 #25 Auch Kanal +3 an AVR für Touchpad
                      ; 20.11.2019 #23 MIDI-Dispatcher verbessert, wird öfter ausgeführt
                      ; 10.11.2019 #20 Local Enables auf SPI $2E
                      ; 21.02.2018 #19 Kleine Verzögerung vor Auslesen der Tastenkontakte wg. Emils Geisternoten
                      ; 13.02.2018 #18 Bug in Key Transpose behoben
                      ; 22.11.2018 #17 Split-Handling jetzt nur noch in Tastatur-Scan
                      ; 12.09.2018 #15 Bug in Midi-Kanalwahl behoben
                      ; 14.08.2018 #14 Bug in local_states_off (Dyn. 1 gesendet) behoben
                      ; 09.08.2018 #12 Sostenuto-Controller 42 geändert auf 45, HOLD2-Pedal wg. NI B4-PERC Konflikt
                      ; 24.04.2018 #11 Bugfixes für Fatar
                      ; 20.10.2017 #10 Zusätzlicher MIDI-Ausgang für SAM5504
                      ; 10.10.2017 Angepasst für KCPSM6, Inputs für Cancel Manual und HW-Sostenuto/Sustain auf PL Auxiliary
                      ; Pins schalten nach Masse!
                      ; Pin 6 = Bit 5 Sustain Upper
                      ; Pin 5 = Bit 4 Sostenuto Upper
                      ; Pin 4 = Bit 3 Sustain Lower
                      ; Pin 3 = Bit 2 Sostenuto Lower
                      ; Pin 2 = Bit 1 Cancel MIDI Kanal invert., 11 = Cancel Off, 10 = Cancel Upper,
                      ; Pin 1 = Bit 0 Cancel MIDI Kanal invert., 01 = Cancel Lower, 00 = Cancel Pedal
                      ;
                      ; $60=SR4014, $61=Fatar, $62=Opto, $63=MIDI, $64=OrganScan61, $65=XB2-5, $66=Fatar61 (neu), $67=Fatar73 (neu, mit Presets)
                      CONSTANT c_corerevi, 52              ; Revisionsnummer
                      CONSTANT c_corevers, 65
                      CONSTANT c_corevers_midionly, 63     ; zum Vergleichen im MIDI-Scan-Treiber
                      CONSTANT c_dyn_threshold, 40         ; MIDI-Dynamikschwelle für full click
                      CONSTANT c_midi_mindyn, 10           ; MIDI-Minimaldynamik langsame Taste
                      ; Timerwert 06 bei äußerst schneller Taste, 7E bei langsamer Taste, XB2-Tataturcontroller zählt nur mit 7 Bit
                      CONSTANT c_time_offset, 0A           ; Offset, wird von Velocity-Zeit des Tastaturcontrollers abgezogen
                      CONSTANT c_time_threshold, A0        ; Velocity-Zeitschwelle für full click
                      ;
                      ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
                      ; Je nach Tastaturumfang sind anzupassen:
                      CONSTANT c_maxkeys, 60'd             ; längste vorhandene Tastatur (44/49/61) +1
                      CONSTANT c_maxkeys_plus1, 61'd       ; längste vorhandene Tastatur (44/49/61) +1
                      CONSTANT c_maxkeys_8x8, 64'd         ; für Matrix-Abfrage
                      CONSTANT c_maxbasskeys, 25'd         ; Anzahl der Pedal-Tasten an AuxPort PL8
                      CONSTANT c_midi_firstkey, 24'd
                      CONSTANT c_midi_lastkey_plus1, 109'd
                      CONSTANT c_gen_firstkey, 36'd        ; Tonumfang INPUT MIDI-Notennummern
                      CONSTANT c_gen_lastkey_plus1, 97'd   ; 96+1 wg. COMPARE
                      CONSTANT c_midi_offset, 36'd         ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
                      CONSTANT c_scankey_delay, 24'd       ; Hardware-Timer in SYNC-Ticks (20,833 µs), default 500 µs Scandurchlauf
                      ;
                      ;
                      ; ##############################################################################
                      ;
                      ;    ### #     #  #####  #       #     # ######  #######
                      ;     #  ##    # #     # #       #     # #     # #
                      ;     #  # #   # #       #       #     # #     # #
                      ;     #  #  #  # #       #       #     # #     # #####
                      ;     #  #   # # #       #       #     # #     # #
                      ;     #  #    ## #     # #       #     # #     # #
                      ;    ### #     #  #####  #######  #####  ######  #######
                      ;
                      ; ##############################################################################
                      ;
                      INCLUDE "registers.psm"
                      INCLUDE "init.psm"
                      INCLUDE "switches.psm"               ; Fußschalter einlesen und verarbeiten
                      ; INCLUDE "states.psm"               ; Zustandsautomaten für Tastenverarbeitung
                      INCLUDE "states_dyntable.psm"        ; Zustandsautomaten für Tastenverarbeitung, mit BRAM-Dynamiktabelle
                      INCLUDE "events_mpx.psm"             ; Event-Loop für MPX-RAM Verarbeitung
                      INCLUDE "timers.psm"                 ; Timer-Routinen für Zustandsautomaten
                      INCLUDE "midi_io.psm"                ; MIDI-Subroutinen für MIDI-Empfang
                      ;
                      ; ###############################################################################
                      ;
                      ;    #     #    #    ### #     #
                      ;    ##   ##   # #    #  ##    #
                      ;    # # # #  #   #   #  # #   #
                      ;    #  #  # #     #  #  #  #  #
                      ;    #     # #######  #  #   # #
                      ;    #     # #     #  #  #    ##
                      ;    #     # #     # ### #     #
                      ;
                      ; ###############################################################################
                      ;
          cold_start: 
                      ; Einsprungpunkt nach Laden des Scan Cores
                      DISABLE INTERRUPT
                      CALL port_init
                      CALL scan_init
                      ;
                      ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
           main_loop: 
                      ; MIDI hat Timing-mäßig Vorrang vor eigener Tastatur,
                      ; um Buffer-Überläufe zu verhindern
                      CALL midi_rx_check                   ; MIDI-Daten empfangen? - ca. 1,7 µs
                      ; auf Scan-Freigabe durch Timer warten
                      INPUT s0, SCANTIMER_ZERO             ; auf Scan-Freigabe warten
                      COMPARE s0, 00                       ; Scan-Timer abgelaufen?
                      JUMP Z, main_loop
                      CALL scantimer_start                 ; Scan-Timer neu starten
                      ; Tastenzustand aller Manuale ermitteln und behandeln
                      ; Zeitbedarf ca. 200 µs (neu!) für Manuale, plus 40 µs für Pedal
                      CALL local_scan_keybds
                      ; CALL local_scan_pedal
                      ;
                      ; Zeitbedarf für das gesamte Handling 137 µs
                      CALL scan_config                     ; Parameter-Änderungen? - ca. 3,4µs
                      CALL handle_sustain_sw               ; Sustain/Sostenuto-Eingangspins
                      CALL update_noisetimers              ; alle Noise-Timer updaten - ca. 26 µs, in 1 ms Abstand
                      ; CALL active_sensing                   ; ca. 1,3 µs
                      CALL midi_rx_check                   ; MIDI-Daten empfangen? - ca. 1,7 µs
                      CALL event_handling                  ; Tasten auswerten, ca. 106 µs
                      ;
                      JUMP main_loop
                      ;
                      ;
                      ; ###############################################################################
                      ;
                      ;    ######  ####### ######  #######
                      ;    #     # #     # #     #    #
                      ;    #     # #     # #     #    #
                      ;    ######  #     # ######     #
                      ;    #       #     # #   #      #
                      ;    #       #     # #    #     #
                      ;    #       ####### #     #    #
                      ;
                      ; ###############################################################################
                      ;
                      ; Scan Port Initialisierung und Hilfsroutinen
                      ;
                      ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ; XB2/XB5-Ports
                      ; K_ACK, 00        XB2, SCANPIO1
                      ; K_ENALWR, 01     XB2, SCANPIO2
                      ; K_ENAUPR, 02     XB2, SCANPIO3
                      ; K_RST, 03        XB2, SCANPIO4
                      ; K_EMPTY, 0E      XB2, Data Present (D6) AUXPIO7
                      ; K_STB, 0F        XB2, AUXPIN8
                      ; K_DATA, 18       XB2, AUXPORT
                      ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
                      ; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
                      ;
           port_init: 
                      ; Scan-Ports initialisieren
                      LOAD s0, 3F                          ; für XB2
                      OUTPUT s0, SCANPORT_DDR
                      LOAD s0, 00                          ; für Bass/Aux-Interface
                      OUTPUT s0, AUXPORT_DDR
                      LOAD s0, 00                          ; Sustainpedal, alles Eing?nge
                      OUTPUT s0, SWITCHPORT_DDR
                      ; hier: XB2-Tastatur-Reset
                      CALL xb2_reset
                      RETURN 
                      ;
          pulse_test: 
                      CALL pulse_test_on                   ; Test für Timing-Analyse
                      CALL delay_600ns
      pulse_test_off: 
                      LOAD s0, 00
                      OUTPUT s0, AUXPIO6                   ; Test für Timing-Analyse
                      RETURN 
       pulse_test_on: 
                      LOAD s0, 01
                      OUTPUT s0, AUXPIO6                   ; Test für Timing-Analyse
                      RETURN 
                      ;
                      ;
                      ; ###############################################################################
                      ;
                      ;     ######  ####### ######     #    #
                      ;     #     # #       #     #   # #   #
                      ;     #     # #       #     #  #   #  #
                      ;     ######  #####   #     # #     # #
                      ;     #       #       #     # ####### #
                      ;     #       #       #     # #     # #
                      ;     #       ####### ######  #     # #######
                      ;
                      ; ###############################################################################
                      ;
                      ; ------------------------------------------------------------------------------
                      ; Hier nur für Split
                      ; ------------------------------------------------------------------------------
                      ;
    local_scan_pedal: ; kein Pedal angeschlossen
                      RETURN 
                      ;
    local_handle_ped: ; Für Split auf Pedal
                      AND s3_keystatus, 01
                      LOAD s9_manual_select, 02            ; für MIDI OUTPUT Lower
                      FETCH s0, s_transpose
                      ADD s0, s5_scan_key
                      STORE s0, s_local_key                ; Für Event-MPX und MIDI Send
                      ; weiter mit Pedal State Machine und dann zurück
                      ;
                      ; -------------------------- Mealy-Zustandsautomat -----------------------------
                      ;
                      ; State in s2: c_state_idle_pedal, c_state_on_pedal
                      ;
                      ; ------------------------------------------------------------------------------
                      ;
                      ; Pedal hat nur 1 Bit im RAM, deshalb andere State Machine
                      CALL local_rd_state_s2               ; Timer-State dieser Taste in s2
                      ; auf derzeitigen Zustand verteilen
                      COMPARE s2, c_state_on_pedal
                      JUMP Z, local_was_on_pedal           ; war vorher ON
                      ;
local_was_idle_pedal: ; war vorher OFF
                      COMPARE s3_keystatus, c_pedal_idle   ; Hat Taste mindestens ersten Kontakt erreicht?
                      RETURN Z                             ; war bereits in Ruhestellung, nichts machen
  local_new_on_pedal: 
                      LOAD s2, c_state_on_pedal
                      CALL local_wr_state_s2               ; neuer Timer-State: c_state_on_pedal
                      LOAD s3_keystatus, c_pedal_on
                      CALL local_wr_s3_keystat             ; neuer Kontakt: ON
                      LOAD s0, 41                          ; Pedal ON senden
                      STORE s0, s_local_dyn
                      JUMP local_states_out                ; Eintragen, MIDI ON senden und Ende
                      ;
  local_was_on_pedal: ; war vorher ON
                      COMPARE s3_keystatus, c_pedal_on     ; Taste noch in ON-Stellung?
                      RETURN Z                             ; war bereits eingeschaltet, nichts machen
 local_new_off_pedal: 
                      LOAD s2, c_state_idle_pedal
                      CALL local_wr_state_s2               ; neuer Timer-State: c_state_idle_pedal
                      LOAD s3_keystatus, c_pedal_idle
                      CALL local_wr_s3_keystat             ; neuer Kontakt: OFF
                      LOAD s0, 00                          ; Pedal OFF senden
                      STORE s0, s_local_dyn
                      JUMP local_states_out                ; Eintragen, MIDI OFF senden und Ende
                      ;                      ;
                      ; ###############################################################################
                      ;
                      ;     #    # ####### #     # ######  ######
                      ;     #   #  #        #   #  #     # #     #
                      ;     #  #   #         # #   #     # #     #
                      ;     ###    #####      #    ######  #     #
                      ;     #  #   #          #    #     # #     #
                      ;     #   #  #          #    #     # #     #
                      ;     #    # #######    #    ######  ######
                      ;
                      ; ###############################################################################
                      ;
                      ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ; XB2/XB5-Ports
                      ; K_ACK, 00        XB2, SCANPIO1 D0 OUTPUT
                      ; K_ENALWR, 01     XB2, SCANPIO2 D1 OUTPUT
                      ; K_ENAUPR, 02     XB2, SCANPIO3 D2 OUTPUT
                      ; K_RST, 03        XB2, SCANPIO4 D3 OUTPUT
                      ; K_EMPTY, 0E      XB2, AUXPIO7 Data Present (D6) INPUT
                      ; K_STB, 0F        XB2, AUXPIN8 INPUT
                      ; K_DATA, 18       XB2, AUXPORT
                      ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
         xb2_delay_4: 
                      LOAD s0, 04
                      JUMP xb2_delay_loop
        xb2_delay_32: 
                      LOAD s0, 20
                      JUMP xb2_delay_loop
       xb2_delay_255: 
                      LOAD s0, FF
      xb2_delay_loop: 
                      SUB s0, 01
                      JUMP NZ, xb2_delay_loop
                      RETURN 
                      ;
        xb2_keys2ram: 
                      ; zunächst XB2-RAM komplett löschen
                      LOAD s0, 00
                      OUTPUT s0, RAM_WRDATA                ; zu schreibende Daten in s0
                      LOAD s5_scan_key, 00
                      LOAD s6_idx_ptr, c_page_xb2data
                      OUTPUT s6_idx_ptr, RAM_PAGE          ; MPX-RAM Page 0 = Tastenkontakte
      xb2_erase_loop: 
                      ; Schleife zum Löschen des XB2-Scratchpads. Wird einmal vor der Tastaturabfrage
                      ; ausgeführt. XB2 liefert nur gedrückte Tasten mit zugehöriger ON-Dynamik.
                      OUTPUT s5_scan_key, RAM_ADDR
                      ADD s5_scan_key, 01
                      OUTPUT s0, UPPER_STROBE
                      OUTPUT s0, LOWER_STROBE
                      OUTPUT s0, PEDAL_STROBE
                      COMPARE s5_scan_key, c_maxkeys_plus1
                      JUMP NZ, xb2_erase_loop
                      ;
                      ; nun gedrückte Tasten mit Dynamik eintragen, Rest des RAMs bleibt 0
                      LOAD s9_manual_select, 00            ; XB2 Abfrage Upper
                      LOAD s0, 01
                      OUTPUT s0, K_ENAUPR
                      CALL xb2_delay_32
                      CALL xb2_getkeys
                      LOAD s0, 00
                      OUTPUT s0, K_ENAUPR
                      ;
                      LOAD s9_manual_select, 01            ; XB2 Abfrage Lower
                      OUTPUT s9_manual_select, K_ENALWR    ; auf 1 setzen
                      CALL xb2_delay_32
                      CALL xb2_getkeys
                      LOAD s0, 00
                      OUTPUT s0, K_ENALWR
                      LOAD s5_scan_key, 00
                      RETURN 
                      ;
                      ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
         xb2_getkeys: 
                      ; Tasten eines XB2-/XB5-Manuals einsammeln
                      CALL xb2_wait_stb                    ; Warten auf K_STB = 1
                      INPUT s0, K_EMPTY                    ; Empty-Bit (D6) gesetzt?
                      COMPARE s0, 01
                      RETURN Z                             ; nichts (mehr) gedrückt, beenden
                      ;
                      ; K_EMPTY war low, Daten sind abzuholen
                      INPUT s5_scan_key, K_DATA            ; 1. Datenbyte Tastennummer
                      AND s5_scan_key, 3F
                      CALL xb2_send_ack                    ; ACK senden und auf K_STB = high warten
                      ;
                      INPUT s3_keystatus, K_DATA           ; 2. Datenbyte Timer, kleine Werte = schnell
                      AND s3_keystatus, 7F
                      CALL xb2_send_ack                    ; ACK senden und auf K_STB = high warten
                      ;
                      ; Dynamik-Daten (s3_keystatus) in XB2-RAM eintragen, PAGE ist noch richtig gesetzt
                      OUTPUT s3_keystatus, RAM_WRDATA      ; zu schreibende Daten in s3_keystatus
                      OUTPUT s5_scan_key, RAM_ADDR
                      LOAD s6_idx_ptr, s9_manual_select    ; 0 oder 1
                      ADD s6_idx_ptr, BASE_STROBE
                      OUTPUT s0, (s6_idx_ptr)              ; Upper oder Lower Write Strobe
                      JUMP xb2_getkeys                     ; weitere Tasten?
                      ;
        xb2_send_ack: 
                      ; K_ACK-Impuls senden und auf K_STB = high warten
                      LOAD s0, 01
                      OUTPUT s0, K_ACK
                      CALL xb2_delay_32
                      LOAD s0, 00
                      OUTPUT s0, K_ACK
                      CALL xb2_delay_4
                      ; anschließend auf K_STB = 1 warten
        xb2_wait_stb: 
                      ; Warten auf K_STB = 1
                      INPUT s0, K_STB
                      COMPARE s0, 01
                      JUMP NZ, xb2_wait_stb
                      CALL xb2_delay_4
                      RETURN 
                      ;
           xb2_reset: 
                      LOAD s0, 00
                      OUTPUT s0, K_ENAUPR
                      OUTPUT s0, K_ENALWR
                      OUTPUT s0, K_RST
                      CALL xb2_delay_255
                      LOAD s0, 01
                      OUTPUT s0, K_RST
                      CALL xb2_delay_255
                      RETURN 
                      ;
                      ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
        xb2_read_ram: 
                      ; Tastenzustand aus XB2-RAM lesen, Tasten-Adresse in scan_number
                      OUTPUT s5_scan_key, RAM_ADDR         ; Tastennummer in s0
                      LOAD s6_idx_ptr, c_page_xb2data
                      OUTPUT s6_idx_ptr, RAM_PAGE          ; MPX-RAM Page
                      LOAD s0, s0                          ; NOP für Timing
                      INPUT s3_keystatus, RD_UPPER         ; Upper oder Lower Read
                      INPUT sB_keystatus_lwr, RD_LOWER     ; Upper oder Lower Read
                      RETURN                               ; Dynamik in s3_keystatus
                      ;
                      ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                      ;
   local_scan_keybds: ; Beide Manuale scannen
                      LOAD s0, 01
                      OUTPUT s0, K_RST
                      CALL xb2_keys2ram                    ; Tasten von XB2-Controller einsammeln
                      LOAD s5_scan_key, 00
     local_scan_loop: 
                      CALL xb2_read_ram                    ; Daten Upper/Lower aus RAM lesen, Dynamik in s3_keystatus
                      CALL local_handle_keybds
                      COMPARE s5_scan_key, c_maxkeys       ; alle Tasten abgefragt?
                      RETURN Z
                      ADD s5_scan_key, 01                  ; nächste Taste
                      JUMP local_scan_loop
                      ;
                      ;
                      ; ###############################################################################
                      ;
                      ;     #####  ######  #       ### #######
                      ;    #     # #     # #        #     #
                      ;    #       #     # #        #     #
                      ;     #####  ######  #        #     #
                      ;          # #       #        #     #
                      ;    #     # #       #        #     #
                      ;     #####  #       ####### ###    #
                      ;
                      ; ###############################################################################
                      ;
                      ; Split Mode:
                      ; 0 = Pedal to Lower
                      ; 1 = Lower to Upper
                      ; 2 = Pedal to Upper
                      ; 3 = Lower to Upper +1 Oktave
                      ; 4 = Lower to Upper +2 Oktaven
                      ; 5 = Add Pedal to Lower
                      ;
 local_handle_keybds: 
                      FETCH s0, s_split_on
                      AND s0, 03
                      JUMP Z, local_handle_nosplit         ; Split OFF
                      FETCH s0, s_splitmode
                      COMPARE s0, 00
                      JUMP Z, local_handle_split_0         ; 0 = Pedal to Lower
                      COMPARE s0, 01
                      JUMP Z, local_handle_split_1         ; 1 = Lower to Upper
                      COMPARE s0, 02
                      JUMP Z, local_handle_split_2         ; 2 = Pedal to Upper
                      COMPARE s0, 03
                      JUMP Z, local_handle_split_3         ; 3 = Lower to Upper +1 Oktave
                      COMPARE s0, 04
                      JUMP Z, local_handle_split_4         ; 4 = Lower to Upper +2 Oktaven
                      JUMP local_handle_split_5            ; 5 = Add Pedal to Lower
                      ;
local_handle_nosplit: 
                      CALL local_wr_upr
                      LOAD s3_keystatus, sB_keystatus_lwr  ; sB_keystatus_lwr für Lower benutzen
                      JUMP local_wr_lwr
                      ;
local_handle_split_0: ; 0 = Pedal to Lower
                      CALL local_wr_upr
                      LOAD s3_keystatus, sB_keystatus_lwr  ; sB_keystatus_lwr für Lower benutzen
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      JUMP NC, local_wr_lwr                ; JUMP wenn s5_scan_key > splitpoint
                      ; sB_keystatus_lwr für Pedal benutzen
                      JUMP local_wr_ped_split
                      ;
local_handle_split_1: ; 1 = Lower to Upper
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      JUMP NC, local_wr_upr                ; JUMP wenn s5_scan_key > splitpoint
                      ; Mode 1, Upper manual key auf Lower schreiben
                      ; s3_keystatus für Lower benutzen
                      LOAD s8_msb, 00                      ; Octave Transpose 0
                      JUMP local_wr_lwr_add_s8
                      ;
local_handle_split_2: ; 2 = Pedal to Upper
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      JUMP NC, local_wr_upr                ; JUMP wenn s5_scan_key > splitpoint
                      ; s3_keystatus (Upper) für Pedal benutzen
                      JUMP local_wr_ped_split
                      ;
local_handle_split_3: ; 3 = Lower to Upper +1 Oktaven
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      JUMP NC, local_wr_upr                ; JUMP wenn s5_scan_key > splitpoint
                      ; wie Mode 1, Upper manual key auf Lower schreiben
                      LOAD s8_msb, 12'd                    ; + 1 Oktave
                      JUMP local_wr_lwr_add_s8
                      ;
local_handle_split_4: ; 4 = Lower to Upper +2 Oktaven
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      JUMP NC, local_wr_upr                ; JUMP wenn s5_scan_key > splitpoint
                      ; wie Mode 1, Upper manual key auf Lower schreiben
                      LOAD s8_msb, 24'd                    ; + 2 Oktaven
                      JUMP local_wr_lwr_add_s8
                      ;
local_handle_split_5: ; 5 = Add Pedal to Lower
                      CALL local_wr_upr
                      LOAD s3_keystatus, sB_keystatus_lwr  ; sB_keystatus_lwr für Lower benutzen
                      CALL local_wr_lwr
                      FETCH s0, s_splitpoint
                      COMPARE s5_scan_key, s0
                      RETURN NC
                      ; sB_keystatus_lwr für Pedal benutzen
                      JUMP local_wr_ped_split              ; Lower key auch auf Pedal schreiben
                      ;
                      ; -------------------------------- UPPER/LOWER ---------------------------------
                      ;
        local_wr_upr: 
                      LOAD s9_manual_select, 00            ; Upper ausgewählt
                      FETCH s0, s_transpose
                      ADD s0, s5_scan_key
                      ; Falls Bits 4 in SPI_SPLITON gesetzt, Oktav-Shift ausführen (MAG Organs 4-Oktaven-Modell)
                      FETCH s1, s_split_on
                      TEST s1, 10                          ; AND -> Z-Flag, Bit 4
                      CALL NZ, local_sub12_s0              ; MAG Mini, Octave Shift?
                      STORE s0, s_local_key                ; Für Event-MPX und MIDI Send
                      STORE s3_keystatus, s_local_dyn
                      JUMP local_states_xb2                ; Eintragen, MIDI senden und Ende
                      ;
        local_wr_lwr: 
                      LOAD s8_msb, 00                      ; Octave Transpose 0
 local_wr_lwr_add_s8: 
                      LOAD s9_manual_select, 01            ; Lower ausgewählt
                      FETCH s0, s_transpose
                      ADD s0, s5_scan_key
                      ; Falls Bit 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen (MAG Organs 4-Oktaven-Modell)
                      FETCH s1, s_split_on
                      TEST s1, 20                          ; AND -> Z-Flag, Bit 5
                      CALL NZ, local_sub12_s0              ; MAG Mini, Octave Shift?
                      ADD s0, s8_msb
                      STORE s0, s_local_key                ; Für Event-MPX und MIDI Send
                      STORE sB_keystatus_lwr, s_local_dyn
                      JUMP local_states_xb2                ; Eintragen, MIDI senden und Ende
                      ;
      local_sub12_s0: ; Shift Upper -1 Oktave auf s0
                      SUB s0, 12'd                         ; transp. Key in s0'
                      RETURN 
                      ;
                      ; ------------------------------ PEDAL SPLIT ------------------------------------
                      ;
  local_wr_ped_split: ; Einsprung für gesplittetes Pedal
                      COMPARE s5_scan_key, c_maxbasskeys   ; wenn s5_scan_key > c_maxbasskeys
                      RETURN NC
                      COMPARE s3_keystatus, 00             ; Taste ausgeschaltet?
                      JUMP Z, local_handle_ped
                      LOAD s3_keystatus, c_pedal_on        ; keine Dynamik, nur ON/OFF
                      JUMP local_handle_ped
                      ;
                      ; ------------------------ State Machine für XB2-Scan ---------------------------
                      ;
    local_states_xb2: 
                      CALL local_rd_state_s2               ; Timer-State dieser Taste in s2
                      ; auf derzeitigen Zustand verteilen
                      COMPARE s2, c_state_stopped
                      JUMP Z, local_was_on_xb2             ; war vorher ON
                      ;
  local_was_idle_xb2: ; war vorher OFF
                      COMPARE s3_keystatus, 00             ; Hat Taste mindestens ersten Kontakt erreicht?
                      RETURN Z                             ; war bereits in Ruhestellung, nichts machen
    local_new_on_xb2: 
                      LOAD s2, c_state_stopped
                      CALL local_wr_state_s2               ; neuer Timer-State: c_key_on
                      LOAD s0, s3_keystatus                ; Zeit ist in s3_keystatus
                      ; Timerwert 04 bei äußerst schneller Taste, 7E bei langsamer Taste, XB2-Tataturcontroller zählt nur mit 7 Bit
                      SUB s0, c_time_offset                ; Offset abziehen, um Dynamik etwas zu entzerren
                      CALL C, xb2_load_zero                ; falls jetzt negativ, mit 0 laden
                      ; SL0 s0                             ; Timer in s0 ggf. hochskalieren, max. 254
                      OUTPUT s0, DYN_TABLE_ADDR            ; Adresse für Dyntable schreiben
                      LOAD s0, s0                          ; Delay für BRAM Zugriff
                      INPUT s0, DYN_TABLE                  ; Dyntable-Wert in s0, 127 = schnellste Taste, 10 = langsamste Taste
                      STORE s0, s_local_dyn
                      JUMP local_states_out                ; Eintragen, MIDI ON senden und Ende
                      ;
    local_was_on_xb2: ; war vorher ON
                      COMPARE s3_keystatus, 00             ; Taste noch in ON-Stellung?
                      RETURN NZ                            ; war bereits eingeschaltet, nichts machen
   local_new_off_xb2: 
                      LOAD s2, c_state_idle
                      CALL local_wr_state_s2               ; neuer Timer-State: c_state_idle_xb2
                      JUMP local_states_out                ; Eintragen, MIDI OFF senden und Ende
                      ;
       xb2_load_zero: 
                      LOAD&RETURN s0, 00
