                        ; ##############################################################################
                        ;
                        ;     #     # ### ######  ###     ### #######
                        ;     ##   ##  #  #     #  #       #  #     #
                        ;     # # # #  #  #     #  #       #  #     #
                        ;     #  #  #  #  #     #  #       #  #     #
                        ;     #     #  #  #     #  #       #  #     #
                        ;     #     #  #  #     #  #       #  #     #
                        ;     #     # ### ######  ###     ### #######
                        ;
                        ; ##############################################################################
                        ;
                        ; MIDI-Subroutinen für MIDI-Empfang
                        ; Dispatcher stellt fest, ob und was es zu tun gibt
                        ; wird regelmäßig aus Hauptschleife aufgerufen
                        ;
     midi_rx_writedata: 
                        ; Notenwert und Dynamik abspeichern
                        ; Dynamik ist 0 bei Key-Off-Befehl
                        FETCH s0, s_midi_data1                           ; MIDI-Transponierung
                        FETCH s1, s_transpose
                        ADD s0, s1
                        STORE s0, s_midi_data1
                        CALL midi_adj_foldbk                             ; Foldback, sollte evt. abschaltbar sein!
                        ; s_midi_data1 ist jetzt innerhalb 36..96
                        ; Empfangsdaten setzen, MIDI-Taste/Dynamik/Manual
                        ; s_midi_data1, s_midi_data2 und s9_manual_select ins RAM, 12..121
                        ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und s9_manual_select ins RAM
                        ;STORE s0, s_midi_data1
                        ;
                        ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und s9_manual_select ins RAM 0..60
                        ;
                        LOAD s6_idx_ptr, c_page_velocity
                        OUTPUT s6_idx_ptr, RAM_PAGE                      ; MPX-RAM Page
                        FETCH s0, s_midi_data2                           ; Dynamik dieser Taste
                        OUTPUT s0, RAM_WRDATA                            ; zu schreibende Dynamik in s0
                        FETCH s0, s_midi_data1                           ; MIDI-Key in s0, geht von 12 bis 121
                        SUB s0, c_gen_firstkey
                        OUTPUT s0, RAM_ADDR
                        ; Dynamik schreiben
                        LOAD s6_idx_ptr, s9_manual_select                ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)                          ; Upper, Lower oder Pedal Strobe
                        ; Umgerechnet in 2 Stufen für Event-Loop
                        LOAD s6_idx_ptr, c_page_latestep
                        OUTPUT s6_idx_ptr, RAM_PAGE                      ; MPX-RAM Page
                        FETCH s0, s_midi_data2                           ; Dynamik dieser Taste
                        COMPARE s0, 00
                        CALL NZ, event_dyn2s0
                        LOAD s8_msb, s0
                        OUTPUT s0, RAM_WRDATA                            ; zu schreibender Step in s0
                        LOAD s6_idx_ptr, s9_manual_select                ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)                          ; Upper, Lower oder Pedal Strobe
                        ; auch für Early-Modus
                        LOAD s6_idx_ptr, c_page_earlystep
                        OUTPUT s6_idx_ptr, RAM_PAGE                      ; MPX-RAM Page
                        LOAD s0, s8_msb                                  ; Step dieser Taste
                        OUTPUT s0, RAM_WRDATA                            ; zu schreibender Step in s0
                        LOAD s6_idx_ptr, s9_manual_select                ; 0 oder 1
                        ADD s6_idx_ptr, c_strobe_mask
                        OUTPUT s0, (s6_idx_ptr)                          ; Upper, Lower oder Pedal Strobe
                        RETURN 
                        ;
                        ;
                        ; ##############################################################################
                        ;
                        ;     #     # ### ######  ###    ######  #     #
                        ;     ##   ##  #  #     #  #     #     #  #   #
                        ;     # # # #  #  #     #  #     #     #   # #
                        ;     #  #  #  #  #     #  #     ######     #
                        ;     #     #  #  #     #  #     #   #     # #
                        ;     #     #  #  #     #  #     #    #   #   #
                        ;     #     # ### ######  ###    #     # #     #
                        ;
                        ; ##############################################################################
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; Gemeinsame MIDI-RX-Verarbeitung nach Empfang eines vollständigen Datensatzes
                        ; für MIDI ONLY und FATAR
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
         midi_rx_check: 
  midi_rx_check_loop_1: 
                        INPUT s0, MIDI_IN1_STATUS
                        COMPARE s0, 00                                   ; Daten empfangen?
                        JUMP Z, midi_rx_check_loop_2                     ; wenn nein, weiter mit MIDI In 2 (SAM/USB)
                        CALL midi_1_getbyte                              ; Buffer lesen/leeren, Realtime filtern, Flags setzen
                        FETCH s0, s_midi_1_rxflag
                        COMPARE s0, 00
                        CALL NZ, midi_rx_decode_1                        ; interpretieren, falls komplett
                        JUMP midi_rx_check_loop_1
                        ;
  midi_rx_check_loop_2: 
                        INPUT s0, MIDI_IN2_STATUS
                        COMPARE s0, 00                                   ; Daten empfangen?
                        JUMP Z, midi_rx_check_loop_sam                   ; wenn nein, weiter mit MIDI In 3 (AVR)
                        CALL midi_2_getbyte                              ; Buffer leeren
                        FETCH s0, s_midi_2_rxflag
                        COMPARE s0, 00
                        CALL NZ, midi_rx_decode_2                        ; interpretieren, falls komplett
                        JUMP midi_rx_check_loop_2
                        ;
midi_rx_check_loop_sam: 
                        FETCH s0, s_midi_sam_has_fifo                    ; eigener FIFO im FPGA für SAM MIDI IN?
                        TEST s0, 01                                      ; Feature-Flag, 01 bei neuem FPGA
                        JUMP Z, midi_rx_check_loop_avr                   ; skip wenn 00 = nicht vorhanden
                        ; wenn kein FIFO vorhanden ist, kommen SAM-Daten auf IN 2 an
                        ;
                        INPUT s0, MIDI_SAM_STATUS
                        COMPARE s0, 00                                   ; Daten empfangen?
                        JUMP Z, midi_rx_check_loop_avr                   ; wenn nein, weiter mit MIDI IN AVR
                        CALL midi_sam_getbyte                            ; Buffer leeren
                        FETCH s0, s_midi_sam_rxflag
                        COMPARE s0, 00
                        CALL NZ, midi_rx_decode_sam                      ; interpretieren, falls komplett
                        JUMP midi_rx_check_loop_sam
                        ;
midi_rx_check_loop_avr: 
                        INPUT s0, MIDI_AVR_STATUS
                        AND s0, 0E                                       ; Daten empfangen?
                        RETURN Z                                         ; wenn nein, zur�ck zur Main Loop
                        CALL midi_avr_getbyte                            ; Buffer lesen/leeren, Flags setzen
                        FETCH s0, s_midi_avr_rxflag
                        COMPARE s0, 00
                        CALL NZ, midi_rx_check_avr                       ; interpretieren, falls komplett
                        JUMP midi_rx_check_loop_avr
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; Daten von AVR getrennt auswerten
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
     midi_rx_check_avr: 
                        ; bei AVR  Controller Change nur auf ALL NOTES OFF pr�fen, sonst senden
                        LOAD s0, 00
                        STORE s0, s_midi_avr_rxflag                      ; Rx-Flag löschen
                        FETCH s0, s_midi_avr_cmd
                        AND s0, F0
                        COMPARE s0, B0                                   ; Control Change?
                        JUMP NZ, midi_rx_check_avr_send
                        FETCH s0, s_midi_avr_cmd
                        AND s0, 0F                                       ; Kanal isolieren
                        STORE s0, s_midi_chan_masked                     ; für allnotesoff_manual
                        FETCH s0, s_midi_avr_data1
                        COMPARE s0, 123'd                                ; All Notes OFF?
                        JUMP Z, allnotesoff_manual
midi_rx_check_avr_send: 
                        ; empfangenen Datensatz 1 bis 3 Bytes vom AVR an SAM und DIN-Buchse senden
                        FETCH s0, s_midi_avr_cmd
                        CALL midi_tx_s0
                        FETCH s0, s_midi_avr_len
                        COMPARE s0, 00
                        RETURN Z
                        ;
                        FETCH s0, s_midi_avr_data1
                        CALL midi_tx_s0
                        FETCH s0, s_midi_avr_len
                        COMPARE s0, 01
                        RETURN Z
                        ;
                        FETCH s0, s_midi_avr_data2
                        JUMP midi_tx_s0
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; Daten von MIDI 1, 2 oder SAM sind vollständig, jetzt auswerten
                        ; hier kein SysEx mehr, wurde bereits direkt weitergeleitet
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
      midi_rx_decode_1: 
                        ; Daten vom erstem MIDI-Eingang interpretieren, falls vollständig
                        LOAD s0, 00
                        STORE s0, s_midi_1_rxflag                        ; Rx-Flag löschen
                        LOAD s6_idx_ptr, s_midi_1_cmd
                        JUMP midi_rx_decode_copy                         ; Ende und RETURN
                        ;
      midi_rx_decode_2: 
                        ; Daten vom zweiten MIDI-Eingang interpretieren, falls vollst�ndig
                        LOAD s0, 00
                        STORE s0, s_midi_2_rxflag                        ; Rx-Flag löschen
                        LOAD s6_idx_ptr, s_midi_2_cmd
                        JUMP midi_rx_decode_copy                         ; Ende und RETURN
                        ;
    midi_rx_decode_sam: 
                        ; Daten vom SAM5504 USB MIDI-Eingang interpretieren, falls vollst?ndig
                        LOAD s0, 00
                        STORE s0, s_midi_sam_rxflag                      ; Rx-Flag löschen
                        LOAD s6_idx_ptr, s_midi_sam_cmd
                        ; JUMP midi_rx_decode_copy                           ; Ende und RETURN
   midi_rx_decode_copy: 
                        ; Daten der empfangenen MIDI-Nachricht in die allgemeinen MIDI-Register kopieren
                        FETCH s0, (s6_idx_ptr)                           ; zeigt auf s_midi_xx_cmd
                        STORE s0, s_midi_cmd
                        ADD s6_idx_ptr, 04                               ; zeigt jetzt auf s_midi_xx_data1
                        FETCH s0, (s6_idx_ptr)
                        STORE s0, s_midi_data1
                        ADD s6_idx_ptr, 04                               ; zeigt jetzt auf s_midi_xx_data2
                        FETCH s0, (s6_idx_ptr)
                        STORE s0, s_midi_data2
                        ADD s6_idx_ptr, 04                               ; zeigt jetzt auf s_midi_xx_len
                        FETCH s0, (s6_idx_ptr)
                        STORE s0, s_midi_len
                        ; JUMP midi_rx_decode                           ; Ende und RETURN
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; MIDI-Datensatz vollständig, dekodieren und ggf. RAM beschreiben
                        ; Daten der empfangenen MIDI-Nachricht jetzt in
                        ; s_midi_cmd, s_midi_data1, s_midi_data2, s_midi_len
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
        midi_rx_decode: 
                        CALL midi_sam_waitbuf                            ; Warte bis SAM5504-Buffer aufnahmebereit
                        FETCH s0, s_midi_cmd
                        OUTPUT s0, MIDI_TX_SAM                           ; immer alles an SAM5504 senden
                        FETCH s0, s_midi_len
                        COMPARE s0, 00
                        JUMP Z, midi_rx_decode_0
                        FETCH s0, s_midi_data1
                        OUTPUT s0, MIDI_TX_SAM
                        COMPARE s0, 01
                        JUMP Z, midi_rx_decode_0
                        FETCH s0, s_midi_data2
                        OUTPUT s0, MIDI_TX_SAM
      midi_rx_decode_0: 
                        FETCH s0, s_midi_cmd
                        AND s0, 0F                                       ; Kanal isolieren
                        STORE s0, s_midi_chan_masked
                        FETCH s0, s_midi_cmd
                        AND s0, F0                                       ; Befehl isolieren
                        STORE s0, s_midi_cmd_masked
                        ;
                        LOAD s9_manual_select, 00                        ; Default upper
                        FETCH s1, s_midi_chan_masked
                        FETCH s0, s_midich                               ; eingestellter Kanal, Piano-Maske
                        COMPARE s1, s0                                   ; eingestellter gleich empfangener Kanal?
                        JUMP Z, midi_rx_note                             ; mit s9_manual_select = 0, upper
                        ;
                        ADD s0, 01
                        LOAD s9_manual_select, 01
                        COMPARE s1, s0                                   ; eingestellter Kanal +1?
                        JUMP Z, midi_rx_note
                        ;
                        ADD s0, 01
                        LOAD s9_manual_select, 02                        ; mit s9_manual_select = 2, Pedal
                        COMPARE s1, s0                                   ; eingestellter Kanal +2?
                        JUMP Z, midi_rx_note_pedal
                        ;
                        ; Sonderkanal +3 für Touchpad-CC, nur an AVR
                        ADD s0, 01
                        COMPARE s1, s0                                   ; eingestellter Kanal +3?
                        JUMP Z, midi_to_avr
                        RETURN 
                        ;
                        ; Hier kommen alle Manuale und Pedal an
                        ;
    midi_rx_note_pedal: 
                        ; Pedal-Sonderbehandlung, weil nur ein Bit statt ein Byte abgespeichert wird
                        FETCH s0, s_midi_cmd_masked
                        COMPARE s0, 80
                        JUMP Z, midi_rx_note_off                         ; 0 speichern
                        COMPARE s0, 90
                        JUMP NZ, midi_rx_check_rest                      ; wenn kein ON/OFF
                        ;
                        FETCH s0, s_midi_data2
                        COMPARE s0, 00
                        JUMP Z, midi_rx_note_off                         ; war $90 mit Dynamik 0
                        ;
                        LOAD s0, 01
                        STORE s0, s_midi_data2
                        ; Exit-Behandlung für midi_rx
                        ; Notenwert und Dynamik abspeichern
                        ; Dynamik ist 0 bei Key-Off-Befehl
                        JUMP midi_rx_writedata
                        ;
          midi_rx_note: 
                        ; MIDI-NoteOn/NoteOff-Befehle? Dynamik bereits in s2, Manual in s9_manual_select
                        FETCH s0, s_midi_cmd_masked
                        COMPARE s0, 90
                        JUMP Z, midi_rx_checksplit
                        COMPARE s0, 80
                        JUMP NZ, midi_rx_check_rest                      ; wenn kein ON/OFF
                        ; ist ein ON/OFF-Befehl
      midi_rx_note_off: 
                        LOAD s0, 00                                      ; MIDI-Befehl Taste OFF, Dynamik 0
                        STORE s0, s_midi_data2                           ; Dynamik dieser Taste 0
    midi_rx_checksplit: 
                        LOAD s0, c_corevers
                        COMPARE s0, c_corevers_midionly
                        JUMP NZ, midi_rx_writedata                       ; JUMP wenn kein MIDI-Scan-Driver
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; Dieses Split-Handling nur bei MIDI-Scan-Driver,
                        ; bei Fatar erfolgt Split bereits bei der Tastaturabfrage!
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
                        ; Note-On-Dynamik in s_midi_data2
                        FETCH s0, s_split_on
                        COMPARE s0, 00
                        JUMP Z, midi_rx_writedata
                        ;
                        ; MIDI-Note in s5_scan_key wg. schnellerem Zugriff, temporär benutzt
                        FETCH s5_scan_key, s_midi_data1
                        FETCH s8_msb, s_splitmode
                        FETCH s7_lsb, s_splitpoint                       ; Splitmode in Register wg. schnellerem Zugriff
                        ADD s7_lsb, c_gen_firstkey                       ; um Tastatur-Anfang verschobener Splitpunkt in s2
                        ;
                        COMPARE s9_manual_select, 01                     ; betriff Lower?
                        JUMP Z, midi_rx_check_lower                      ; wenn MIDI auf 1 = Lower
                        COMPARE s9_manual_select, 02                     ; betriff Pedal?
                        JUMP Z, midi_rx_writedata                        ; wenn MIDI auf 2 = Pedal, nie gesplittet
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
   midi_rx_check_upper: 
                        COMPARE s8_msb, 01                               ; Splitmode 1 = Lower to Upper?
                        JUMP Z, midi_rx_check_upper_1
                        COMPARE s8_msb, 02                               ; Splitmode 2 = Pedal to Upper?
                        JUMP Z, midi_rx_check_upper_2
                        COMPARE s8_msb, 03                               ; Splitmode 3 = Lower to Upper +1 Oktave?
                        JUMP Z, midi_rx_check_upper_3
                        COMPARE s8_msb, 04                               ; Splitmode 4 = Lower to Upper +2 Oktaven
                        JUMP Z, midi_rx_check_upper_4
                        JUMP midi_rx_writedata                           ; wenn 0, kein Split für Upper
                        ;
 midi_rx_check_upper_1: 
                        ; wenn unterhalb Splitpunkt, auf LOWER schreiben
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        JUMP midi_rx_remap_to_lower
                        ;
 midi_rx_check_upper_2: 
                        ; wenn unterhalb Splitpunkt, auf PEDAL schreiben
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        JUMP midi_rx_remap_to_pedal                      ; und RETURN
                        ;
 midi_rx_check_upper_3: 
                        ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 1 Oktave darüber
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        ADD s5_scan_key, 12'd                            ; 1 Oktave addieren
                        JUMP midi_rx_remap_to_lower                      ; PEDAL abfragen und RETURN
                        ;
 midi_rx_check_upper_4: 
                        ; hier nur noch 4 = Lower to Upper +2 Oktaven
                        ; wenn unterhalb Splitpunkt, auf LOWER schreiben, 2 Oktaven darüber
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        ADD s5_scan_key, 24'd                            ; 1 Oktave addieren
                        JUMP midi_rx_remap_to_lower                      ; PEDAL abfragen und RETURN
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
   midi_rx_check_lower: 
                        COMPARE s8_msb, 00                               ; Splitmode 0 = Pedal to Lower?
                        JUMP Z, midi_rx_check_lower_0
                        COMPARE s8_msb, 05                               ; Splitmode 0 = Pedal to Lower?
                        JUMP Z, midi_rx_check_lower_5
                        JUMP midi_rx_writedata                           ; JUMP wenn nicht
 midi_rx_check_lower_0: 
                        ; nur 0 = Pedal to Lower behandeln
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        JUMP midi_rx_remap_to_pedal                      ; und RETURN
 midi_rx_check_lower_5: 
                        ; nur 5 = Add Pedal to Lower behandeln
                        COMPARE s5_scan_key, s7_lsb
                        JUMP NC, midi_rx_writedata                       ; JUMP wenn s5_scan_key > splitpoint
                        ; unterhalb Splitpunkt ausgef�hrt:
                        CALL midi_rx_remap_to_lower
                        JUMP midi_rx_remap_to_pedal                      ; und RETURN
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
midi_rx_remap_to_pedal: 
                        LOAD s9_manual_select, 02
                        FETCH s0, s_midi_data2
                        COMPARE s0, 00
                        JUMP Z, midi_rx_writedata                        ; war $90 mit Dynamik 0
                        ;
                        LOAD s0, 01
                        STORE s0, s_midi_data2
                        JUMP midi_rx_writedata                           ; im Main-Programm weiter
                        ;
midi_rx_remap_to_lower: 
                        STORE s5_scan_key, s_midi_data1
                        LOAD s9_manual_select, 01
                        JUMP midi_rx_writedata                           ; im Main-Programm weiter
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ; Ende Split-Handling bei MIDI-Scan-Driver
                        ; Ab hier wieder MIDI und Fatar gemeinsam
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
                        ; MIDI-Tasten außerhalb des 5-Oktaven-Umfangs oktavweise verschieben
                        ;
       midi_adj_foldbk: 
                        FETCH s0, s_midi_data1
     midi_adj_foldbk_1: 
                        COMPARE s0, c_gen_firstkey                       ; Carry bei s5_scan_key - 36?
                        JUMP NC, midi_adj_foldbk_2                       ; Carry nicht gesetzt >=36
                        ADD s0, 12'd
                        JUMP midi_adj_foldbk_1
                        ;
     midi_adj_foldbk_2: 
                        STORE s0, s_midi_data1
                        COMPARE s0, c_gen_lastkey_plus1                  ; Carry bei s5_scan_key - 97?
                        RETURN C
                        SUB s0, 12'd
                        JUMP midi_adj_foldbk_2
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
    midi_rx_check_rest: 
                        ; Program Change und Controller? Dann an AVR
                        ; s0 enthält s_midi_cmd_masked
                        COMPARE s0, C0
                        JUMP Z, midi_to_avr
                        COMPARE s0, E0
                        JUMP Z, midi_to_avr
                        COMPARE s0, B0
                        RETURN NZ                                        ; alles andere unberücksichtigt
          midi_cchange: 
                        ; bei Controller Change auf ALL NOTES OFF prüfen, dann weiter wie Program Change
                        FETCH s0, s_midi_data1                           ; eingestellter Kanal, Piano-Maske
                        COMPARE s0, 123'd                                ; All Notes OFF?
                        JUMP Z, allnotesoff_manual                       ; falls nicht, weiter mit AVR-IRQ
                        ;
           midi_to_avr: 
                        ; AVR-IRQ ausl�sen; MIDI-Daten an SPI
                        FETCH s0, s_midi_cmd
                        OUTPUT s0, MIDI_CMD
                        FETCH s0, s_midi_data1
                        OUTPUT s0, MIDI_DB1
                        FETCH s0, s_midi_data2
                        OUTPUT s0, MIDI_DB2
                        CALL midi_strobe_avr                             ; an AVR senden, benutzt s0
                        ;
                        FETCH s0, s_midi_cmd_masked
                        COMPARE s0, B0                                   ; Control Change empfangen?
                        RETURN NZ
                        ; ab hier nur noch Control Change Bx, auf allen benutzten Kanälen
                        ;
                        INPUT s0, SPI_MIDIOPT                            ; Bit 7 (MSB): USE SOST/SUSTAIN freigeschaltet?
                        AND s0, 80
                        RETURN Z                                         ; wenn 0, dann nicht behandeln, abgeschaltet
                        ;
          midi_sustain: 
                        ; s9_manual_select enth�lt empfangenes Ziel (0, 1 oder 2)
                        COMPARE s1, 40
                        JUMP NZ, midi_sostenuto
                        ;
                        LOAD s6_idx_ptr, s_sustain_upr
                        JUMP midi_sost_sustain                           ; evt. von SAM5504-HW-Input, muss auch gesendet werden
                        ;
        midi_sostenuto: 
                        COMPARE s1, 42
                        RETURN NZ
                        LOAD s6_idx_ptr, s_sosten_upr
     midi_sost_sustain: 
                        ADD s6_idx_ptr, s9_manual_select
                        FETCH s2, s_midi_data2
                        STORE s2, (s6_idx_ptr)
                        ; OUTPUT s0, AUXPORT                    ; ### TEST - nur in MIDI-Scantreiber benutzen! ###
                        ;
                        ; Sustain und Sostenuto weitersenden, könnte vom DSP (Eingangs-Pins über Jumper) stammen
                        CALL midi_out_waitbuf                            ; benutzt s1!
                        FETCH s0, s_midi_cmd
                        OUTPUT s0, MIDI_TX_DIN                           ; TX Midi auf DIN-Buchse
                        FETCH s0, s_midi_data1
                        OUTPUT s0, MIDI_TX_DIN                           ; TX Midi auf DIN-Buchse
                        FETCH s0, s_midi_data2
                        OUTPUT s0, MIDI_TX_DIN                           ; TX Midi auf DIN-Buchse
                        RETURN 
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
            midi_tx_s0: 
                        CALL midi_out_waitbuf                            ; benutzt s1!
                        OUTPUT s0, MIDI_TX_DIN                           ; TX Midi auf beiden Ports
                        OUTPUT s0, MIDI_TX_SAM
                        LOAD s1, 00
                        STORE s1, s_midi_activesensing                   ; Active Sensing Reset
                        RETURN 
                        ;
      midi_out_waitbuf: ; MIDI MAIN OUT
                        INPUT s1, TX_STATUS
                        TEST s1, 0A                                      ; nur 0, wenn beide TX DIN und TX SAM FIFOs nicht voll sind
                        JUMP NZ, midi_out_waitbuf                        ; auf Buffer-Leerung warten
                        RETURN 
                        ;
      midi_sam_waitbuf: ; SAM5504-Buffer aufnahmebereit? Zweiter Eingang
                        INPUT s1, TX_STATUS
                        TEST s1, 08                                      ; nur 0, wenn TX SAM FIFO nicht voll ist
                        JUMP NZ, midi_sam_waitbuf                        ; auf Buffer-Leerung warten
                        RETURN 
                        ;
                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                        ;
          midi_testout: 
                        ; für Debug-Zwecke, sendet MIDI-Programchange mit Wert in s0
                        LOAD s1, C0
                        OUTPUT s1, MIDI_TX_DIN                           ; TX Midi auf DIN-Buchse
                        OUTPUT s1, MIDI_TX_SAM                           ; TX Midi an SAM
                        OUTPUT s0, MIDI_TX_DIN                           ; TX Midi auf DIN-Buchse
                        OUTPUT s0, MIDI_TX_SAM                           ; TX Midi an SAM
                        RETURN 
                        ;
                        ; Active Sensing senden falls Timer abgelaufen
   midi_active_sensing: 
                        FETCH s0, s_midi_activesensing                   ; nach 256 ms Active Sensing senden
                        ADD s0, 01
                        STORE s0, s_midi_activesensing
                        COMPARE s0, 00
                        RETURN NZ
                        ; TEST: Active Sensing abgeschaltet
                        ; RETURN
                        CALL midi_out_waitbuf
                        LOAD s0, FE
                        OUTPUT s0, MIDI_TX_DIN
                        OUTPUT s0, MIDI_TX_SAM
                        RETURN 
                        ;
                        ; ##############################################################################
                        ;
                        ;     #####  ####### #######    ######  #     # ####### #######
                        ;    #     # #          #       #     #  #   #     #    #
                        ;    #       #          #       #     #   # #      #    #
                        ;    #  #### #####      #       ######     #       #    #####
                        ;    #     # #          #       #     #    #       #    #
                        ;    #     # #          #       #     #    #       #    #
                        ;     #####  #######    #       ######     #       #    #######
                        ;
                        ;    M I D I   I N P U T  1 (DIN1)
                        ;    M I D I   I N P U T  2 (DIN2/SAM/USB)
                        ;    M I D I   I N P U T  SAM (USB)
                        ;
                        ; ##############################################################################
                        ;
                        ; 1 MIDI-Byte wurde von Input 1, 2 oder SAM (USB) empfangen
                        ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                        ; Nur noch eine Routine für alle 3 Eingänge, Index wird vorher gesetzt
                        ;
        midi_1_getbyte: 
                        LOAD s6_idx_ptr, 00                              ; Zeigt auf MIDI Input 1
                        INPUT s0, MIDI_IN1
                        JUMP midi_setindex
        midi_2_getbyte: 
                        LOAD s6_idx_ptr, 01                              ; Zeigt auf MIDI Input 2
                        INPUT s0, MIDI_IN2
                        JUMP midi_setindex
      midi_sam_getbyte: 
                        LOAD s6_idx_ptr, 03                              ; Zeigt auf MIDI Input SAM (USB)
                        INPUT s0, MIDI_IN_SAM
                        ; JUMP midi_setindex
                        ;
         midi_setindex: 
                        ; Index für MIDI 1/2 Befehle setzen, s6_idx_ptr enthält 0..3
                        LOAD midi_cmd_idx, c_midi_cmd_base
                        ADD midi_cmd_idx, s6_idx_ptr
                        ;
                        LOAD midi_counter_idx, c_midi_counter_base
                        ADD midi_counter_idx, s6_idx_ptr
                        ;
                        LOAD midi_ignoreflag_idx, c_midi_ignoreflag_base
                        ADD midi_ignoreflag_idx, s6_idx_ptr
                        ;
                        LOAD midi_SysExFlag_idx, c_midi_SysExFlag_base
                        ADD midi_SysExFlag_idx, s6_idx_ptr
                        ;
                        ; MIDI Daten wurden von einem der Inputs empfangen, Byte in s0
                        ; SysCmds ausfiltern, Datenbytes sammeln und Flag setzen wenn vollständig
                        ;
          midi_getbyte: 
                        COMPARE s0, F0                                   ; RealTime ab $F0?
                        JUMP C, midi_channel_message                     ; wenn kleiner als F0, mit Channel Messages weiter
                        COMPARE s0, F8                                   ; RealTime ab $F8?
                        RETURN NC                                        ; Realtime ab #F8 ohne Daten, verwerfen
                        COMPARE s0, F0                                   ; Start of SysEX, Flag setzen
                        JUMP Z, midi_start_avr_sysex
                        COMPARE s0, F7                                   ; End of SysEX, Flag löschen
                        JUMP Z, midi_stop_avr_sysex
                        ; ab hier nur noch Werte zwischen F1 und F6 ?brig:
                        ; F1 Timecode Quarter Frame, F2 Song Position Pointer, F3 Select Song
                        LOAD s1, FF
                        STORE s1, (midi_ignoreflag_idx)                  ; Flag setzen: folgende Daten ignorieren
                        RETURN 
                        ;
  midi_channel_message: 
                        TEST s0, 80
                        JUMP Z, midi_is_databyte                         ; kleiner als $80
                        ; ist ab hier eine Channel Message
                        STORE s0, (midi_cmd_idx)
                        LOAD s1, 00                                      ; ist ein neuer (Running) Status
                        STORE s1, (midi_counter_idx)
                        STORE s1, (midi_ignoreflag_idx)                  ; Flag löschen: bald folgende Daten wieder relevant
                        FETCH s1, (midi_SysExFlag_idx)
                        COMPARE s1, 00
                        JUMP NZ, midi_stop_avr_sysex                     ; Sysex durch Channel-Command beendet
                        RETURN 
                        ;
      midi_is_databyte: 
                        ; MIDI-Byte noch in s0
                        LOAD s2, c_midi_data1_base
                        ADD s2, s6_idx_ptr                               ; s2 wird Pointer auf Datenbyte-1-Scratch
                        ;
                        FETCH s1, (midi_SysExFlag_idx)
                        COMPARE s1, 00                                   ; Läuft SysEx-übertragung?
                        JUMP NZ, midi_avr_sysex_s0                       ; dann Daten zum AVR senden
                        ;
                        FETCH s1, (midi_ignoreflag_idx)                  ; Daten von Sytem Common F1, F2, F3?
                        COMPARE s1, 00
                        RETURN NZ                                        ; Datenbytes ignorieren wenn ja
                        ;
                        FETCH s1, (midi_counter_idx)
                        ADD s1, 01
                        STORE s1, (midi_counter_idx)
                        COMPARE s1, 02
                        JUMP Z, midi_is_db2
                        ; erstes Datenbyte empfangen:
                        ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                        ; Datensatz ist mit einem Datenbyte vollst?ndig!
                        FETCH s1, (midi_cmd_idx)
                        AND s1, F0                                       ; Kanal ausmaskieren
                        COMPARE s1, C0                                   ; program change
                        JUMP Z, midi_is_db_single
                        COMPARE s1, D0                                   ; channel pressure
                        JUMP Z, midi_is_db_single
           midi_is_db1: ; MIDI-Byte noch in s0
                        ; s2 zeigt noch auf c_midi_data1_base + s6_idx_ptr
                        STORE s0, (s2)
                        RETURN 
                        ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
     midi_is_db_single: ; MIDI-Byte noch in s0
                        STORE s0, (s2)                                   ; in beide Datenbytes speichern
           midi_is_db2: ; MIDI-Byte noch in s0
                        ADD s2, 04                                       ; 4 = Offset zu data1
                        STORE s0, (s2)
                        FETCH s1, (midi_counter_idx)
                        LOAD s2, c_midi_len_base
                        ADD s2, s6_idx_ptr                               ; s2 wird Pointer auf Länge-Scratch
                        STORE s1, (s2)                                   ; letzte Anzahl empfangener Datenbytes
                        LOAD s1, 00                                      ; Datensatz vollständig, Counter wieder auf 0
                        STORE s1, (midi_counter_idx)                     ; neue Anzahl empfangener Datenbytes
                        ; Rx-Flag für diesen Eingang setzen
                        LOAD s2, c_midi_rxflag_base
                        ADD s2, s6_idx_ptr
                        LOAD s1, FF
                        STORE s1, (s2)                                   ; jetzt vollständig, RX-Flag setzen
                        RETURN 
                        ;
  midi_start_avr_sysex: 
                        LOAD s1, FF
                        STORE s1, (midi_SysExFlag_idx)
                        JUMP midi_avr_sysex_s0
                        ;
                        ; SysEx-Datenübertragung immer komplett abwarten
   midi_stop_avr_sysex: 
                        LOAD s1, 00
                        STORE s1, (midi_SysExFlag_idx)
                        LOAD s0, F7
                        ; JUMP midi_avr_sysex_s0
     midi_avr_sysex_s0: 
                        ; SysEx-Byte in s0
                        ; 3 Bytes werden parallel übertragen, deshalb Umsetzung auf Controller für AVR-SPI
                        LOAD s1, B0
                        OUTPUT s1, MIDI_CMD
                        LOAD s1, 78                                      ; eigener Controller $78
                        OUTPUT s1, MIDI_DB1
                        OUTPUT s0, MIDI_DB2                              ; SysEx-Daten einschl. F0 und F7, hier 8 Bit zul?ssig!
       midi_strobe_avr: 
                        LOAD s0, 01                                      ; pos. Flanke an MIDI-FIFO
                        OUTPUT s0, MIDI_STR
                        LOAD s0, 00
                        OUTPUT s0, MIDI_STR
                        RETURN 
                        ;
                        ;
                        ; ##############################################################################
                        ; ###################### M I D I   I N P U T  3 (AVR) ##########################
                        ; ##############################################################################
                        ;
                        ; SPI-MIDI Daten wurden von AVR empfangen
                        ; vereinfachte SysEx-Behandlung
      midi_avr_getbyte: 
                        ; LOAD s1, FA ; ##### TEST #####
                        ; OUTPUT s1, AUXPORT ; Trigger für LA
                        ; OUTPUT s0, AUXPORT ; ##### TEST #####
                        INPUT s0, MIDI_AVR
                        COMPARE s0, F0                                   ; SysEx-Start?
                        JUMP Z, midi_startSysEx
                        COMPARE s0, F7                                   ; SysEx-Ende?
                        JUMP Z, midi_stopSysEx
                        FETCH s1, s_midi_avr_SysExFlag
                        COMPARE s1, 00
                        JUMP NZ, midi_tx_s0                              ; s0 Senden, übertragung l�uft noch
                        ;
                        TEST s0, 80
                        JUMP Z, midi_avr_is_db
                        LOAD s1, 00                                      ; ist ein neuer (Running) Status
                        STORE s1, s_midi_avr_counter
                        STORE s1, s_midi_avr_SysExFlag
                        STORE s0, s_midi_avr_cmd
                        RETURN 
        midi_avr_is_db: 
                        FETCH s1, s_midi_avr_counter
                        ADD s1, 01
                        STORE s1, s_midi_avr_counter
                        COMPARE s1, 02
                        JUMP Z, midi_avr_is_db2
                        ; erstes Datenbyte empfangen:
                        ; Sonderfall Ein-Datenbyte-Befehle Program Change und Channel Pressure behandeln
                        ; Datensatz ist mit einem Datenbyte vollst�ndig!
                        FETCH s1, s_midi_avr_cmd
                        AND s1, F0                                       ; Kanal ausmaskieren
                        COMPARE s1, C0                                   ; program change
                        JUMP Z, midi_avr_is_db_single
                        COMPARE s1, D0                                   ; channel pressure
                        JUMP Z, midi_avr_is_db_single
       midi_avr_is_db1: 
                        STORE s0, s_midi_avr_data1
                        RETURN 
                        ; hier landen die Datenbytes von 1-Datenbyte-Befehlen:
 midi_avr_is_db_single: 
                        STORE s0, s_midi_avr_data1
       midi_avr_is_db2: 
                        STORE s0, s_midi_avr_data2
                        FETCH s1, s_midi_avr_counter
                        STORE s1, s_midi_avr_len                         ; Anzahl empfangener Datenbytes
                        LOAD s1, 00                                      ; Datensatz vollst�ndig
                        STORE s1, s_midi_avr_counter                     ; letzte Anzahl empfangener Datenbytes
                        LOAD s1, FF
                        STORE s1, s_midi_avr_rxflag                      ; jetzt vollst�ndig, Flag setzen
                        RETURN 
                        ; SysEx-Daten vom AVR unbehandelt senden, aber Flag setzen
       midi_startSysEx: 
                        CALL midi_tx_s0                                  ; verwendet s1
                        LOAD s1, FF
                        STORE s1, s_midi_avr_SysExFlag
                        RETURN 
        midi_stopSysEx: 
                        CALL midi_tx_s0                                  ; verwendet s1
                        LOAD s1, 00
                        STORE s1, s_midi_avr_SysExFlag
                        RETURN 
                        ;
